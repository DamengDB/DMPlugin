# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ImportDialog
                                 A QGIS plugin
 -TODO:Link to Dameng and import spatail data into the database
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-07-16
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Dameng
        email                : yangzhenyu@dameng.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import asyncio
import dmPython
import uuid
import numpy as np
import re

from qgis.PyQt.QtGui import QRegExpValidator
from PyQt5.QtCore import QVariant, QRegExp ,QTime, QDate, QDateTime
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import pyqtSignal, Qt, QCoreApplication, QThread, pyqtSlot
from qgis.utils import iface
from PyQt5.QtWidgets import QPushButton, QComboBox, QLineEdit, QMessageBox, QProgressBar, QLabel, QVBoxLayout, QWidget
from qgis.core import (
    QgsVectorLayer, QgsGeometry, QgsFeature, QgsProject,
    QgsFields, QgsField, Qgis
)
from .comboFilter import PopupFilter
from .importWorker import ImportWorker
from decimal import Decimal
from datetime import datetime, date, time
# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'import.ui'))


class ImportDialog(QtWidgets.QDialog, FORM_CLASS):
    closingPlugin = pyqtSignal()
    loop: asyncio.AbstractEventLoop

    BackButton: QPushButton

    databaseBox: QComboBox
    tableBox: QComboBox
    columnBox: QComboBox
    operateBox: QComboBox
    typeBox: QComboBox
    limitEdit: QLineEdit
    limitMinEdit: QLineEdit
    limitMaxEdit: QLineEdit
    addLayerButton: QPushButton
    layernameEdit: QLineEdit
    sridEdit: QLineEdit
    progress_bar: QProgressBar
    worker_thread: QThread
    container: QWidget
    
    conn: object
    schema_name: str
    table_name: str
    column_name: str
    operator: str
    type_name: str
    wkt: str
    limit: int
    limit_min: int
    limit_max: int
    layer_name: str
    srid: int
    cursor: object

    def __init__(self, plugin, db_connection):
        """Constructor."""
        super().__init__(plugin.iface.mainWindow())
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.conn = db_connection
        self.plugin = plugin
        self.setupUi(self)
        self.init_layout()
        self.init_schema_box()
        self.progress_bar = None
        self.worker_thread = None
        self.container = None
        # 创建游标
        self.cursor = self.conn.cursor()


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('ImportDialog', message)


    #Init import ui layout:
    #AddLayer bottun: Add layer to QGIS
    #Back bottun: Back to connect layout
    #database Box: Choose schema box
    #table Box: Choose table box
    #column Box: Choose column box
    #operate Box: Choose operate box
    #type Box: Choose type box
    def init_layout(self):
        #关联按钮、下拉列表与函数，操作后触发函数
        self.databaseBox.activated[str].connect(self.schema_box_change)
        self.tableBox.activated[str].connect(self.table_box_change)
        self.columnBox.activated[str].connect(self.column_box_change)
        self.operateBox.activated[str].connect(self.operate_box_change)
        self.typeBox.activated[str].connect(self.type_box_change)
        self.addLayerButton.clicked.connect(self.add_layer_button_clicked)
        self.BackButton.clicked.connect(self.back_button_clicked)
        #正则表达式：只允许输入数字(整数)
        #^[0-9]+$ 表示从开头到结尾必须是1个或多个数字
        int_validator = QRegExpValidator(QRegExp("^[0-9]+$"), self.limitEdit)
        self.limitEdit.setValidator(int_validator)
        int_validator = QRegExpValidator(QRegExp("^[0-9]+$"), self.limitMinEdit)
        self.limitMinEdit.setValidator(int_validator)
        int_validator = QRegExpValidator(QRegExp("^[0-9]+$"), self.limitMaxEdit)
        self.limitMaxEdit.setValidator(int_validator)
        int_validator = QRegExpValidator(QRegExp("^[0-9]+$"), self.sridEdit)
        self.sridEdit.setValidator(int_validator)

        self.databaseBox.setEnabled(False)
        self.databaseBox.clear()
        self.tableBox.setEnabled(False)
        self.tableBox.clear()
        self.columnBox.setEnabled(False)
        self.columnBox.clear()
        self.operateBox.setEnabled(False)
        self.operateBox.clear()
        self.operateBox.addItems(["ALL","=", ">", "<", ">=", "<=", ">=v1 and <=v2"])
        self.typeBox.setEnabled(False)
        self.typeBox.clear()
        self.typeBox.addItems(["Point", "LineString", "Polygon", "MultiPoint", "MultiLineString", "MultiPolygon"])
        self.addLayerButton.setEnabled(False)

        self.reset_operateBox()
        self.reset_typeBox()
        self.reset_limitEdit()
        self.reset_sridEdit()


    #重置operateBox，不可选择且默认显示为ALL
    def reset_operateBox(self):
        self.operateBox.setEnabled(False)
        self.operateBox.setCurrentIndex(0)


    #重置typeBox，不可选择
    def reset_typeBox(self):
        self.typeBox.setEnabled(False)
        self.typeBox.setCurrentIndex(-1) 


    #重置limitEdit，limitEdit不可选择、可见，limitMinEdit、limitMaxEdit不可选择、不可见
    def reset_limitEdit(self):
        self.limitEdit.setEnabled(False)
        self.limitEdit.clear()
        self.limitEdit.show()
        self.limitMinEdit.setEnabled(False)
        self.limitMinEdit.clear()
        self.limitMinEdit.hide()
        self.limitMaxEdit.setEnabled(False)
        self.limitMaxEdit.clear()
        self.limitMaxEdit.hide()


    #重置sridEdit不可选择
    def reset_sridEdit(self):
        self.sridEdit.setEnabled(False)
        self.sridEdit.clear()
        self.sridEdit.show()


    def back_button_clicked(self):
        self.hide()
        self.plugin.show_connect_page()

    
    def is_valid_identifier(self, name: str) -> bool:
        if name.startswith('"') and name.endswith('"'):
            inner = name[1:-1]
            if re.search(r'(?<!")"(?!")', inner):
                return False
            if re.search(r"[';--/*\\]", inner):
                return False
            if len(inner) < 1 or len(inner) > 126:
                return False
            return True
        else:
            if not re.match(r'^[a-zA-Z_$#][a-zA-Z0-9_$#]*$', name):
                return False
            if len(name) < 1 or len(name) > 128:
                return False
            return True

    
    def escape_identifier(self, name: str) -> str:
        if name.startswith('"') and name.endswith('"'):
            inner = name[1:-1]
            escaped_name = inner.replace('"', '""')
            return f'"{escaped_name}"'
        else:
            escaped_name = name.replace('"', '""')
            return f'"{escaped_name}"'


    #初始化schema box的内容，包含当前用户能够访问的所有
    def init_schema_box(self):
        # 创建游标
        cursor = self.conn.cursor()
        try:
                
            # 构建查询SQL
            # 查询当前访问的所有模式
            #sql = """ SELECT USERNAME FROM ALL_USERS ORDER BY USERNAME;"""
            sql = """SELECT * FROM SYSOBJECTS where  TYPE$ ='SCH';"""
            # 执行查询
            cursor.execute(sql)
                
            # 获取所有模式名（提取查询结果的第一列）
            dbs = sorted([row[0] for row in cursor.fetchall()])
            if dbs:
                self.databaseBox.addItems(dbs)
                self.databaseBox.setCurrentIndex(-1)
                self.databaseBox.setEnabled(True)
            for i in range(self.databaseBox.count()):
                self.databaseBox.setItemData(i, self.databaseBox.itemText(i), Qt.ToolTipRole)
            self.databaseBox.view().installEventFilter(PopupFilter(self.databaseBox))
        except Exception as e:
        # 捕获其他未知错误
            iface.messageBar().pushMessage(
                "init schemaBox Error:", 
                sql, 
                level=Qgis.Critical)
        finally:
            if cursor:
                cursor.close()
        

    #schema下拉列表内容改变
    def schema_box_change(self):
        #表下拉列表清空，并设置为不可点击状态
        self.tableBox.setEnabled(False)
        self.tableBox.clear()
        #空间列下拉列表清空，并设置为不可点击状态
        self.columnBox.setEnabled(False)
        self.columnBox.clear()
        #重置operateBox、typeBox、limitEdit、sridEdit
        self.reset_operateBox()
        self.reset_typeBox()
        self.reset_limitEdit()
        self.reset_sridEdit()
        #添加图层按钮设置为不可点击状态
        self.addLayerButton.setEnabled(False)

        self.schema_name = self.databaseBox.currentText()
        cursor = self.conn.cursor()
        try:
            # 构建查询SQL
            # 查询当前模式下所有表
            sql = """ SELECT TABLE_NAME FROM ALL_TABLES WHERE OWNER = ? ORDER BY TABLE_NAME;"""# nosec B608

            # 执行查询
            cursor.execute(sql, (self.schema_name))
                
            # 获取所有表名（提取查询结果的第一列）
            tables = sorted([row[0] for row in cursor.fetchall()])
            if tables:
                self.tableBox.addItems(tables)
                self.tableBox.setCurrentIndex(-1)
                self.tableBox.setEnabled(True)
            for i in range(self.tableBox.count()):
                self.tableBox.setItemData(i, self.tableBox.itemText(i), Qt.ToolTipRole)
            self.tableBox.view().installEventFilter(PopupFilter(self.tableBox))
        except ValueError as e:
            QMessageBox.critical(self, "Input error", str(e))
        except Exception as e:
        # 捕获其他未知错误
            iface.messageBar().pushMessage(
                "Change schemaBox Error:", 
                sql, 
                level=Qgis.Critical)
        finally:
            if cursor:
                cursor.close()
        

    #table下拉列表内容改变
    def table_box_change(self):
        #空间列下拉列表清空，并设置为不可点击状态
        self.columnBox.setEnabled(False)
        self.columnBox.clear()
        #重置operateBox、typeBox、limitEdit、sridEdit
        self.reset_operateBox()
        self.reset_typeBox()
        self.reset_limitEdit()
        self.reset_sridEdit()
        #添加图层按钮设置为不可点击状态
        self.addLayerButton.setEnabled(False)

        self.table_name = self.tableBox.currentText()
        cursor = self.conn.cursor()
        try:
            # 构建查询SQL
            # 查询当前表下所有空间列
            sql = """select F_GEOMETRY_COLUMN from sysgeo2.geometry_columns where F_TABLE_SCHEMA = ? and F_TABLE_NAME = ?;"""# nosec B608

            # 执行查询
            cursor.execute(sql, (self.schema_name), (self.table_name))
                
            # 获取所有列名（提取查询结果的第一列）
            columns = sorted([row[0] for row in cursor.fetchall()])
            if columns:
                self.columnBox.addItems(columns)
                self.columnBox.setCurrentIndex(-1)
                self.columnBox.setEnabled(True)
            for i in range(self.columnBox.count()):
                self.columnBox.setItemData(i, self.columnBox.itemText(i), Qt.ToolTipRole)
            self.columnBox.view().installEventFilter(PopupFilter(self.columnBox))
        except ValueError as e:
            QMessageBox.critical(self, "Input error", str(e))
        except Exception as e:
        # 捕获其他未知错误
            iface.messageBar().pushMessage(
                "Change TableBox Error:", 
                sql, 
                level=Qgis.Critical)
        finally:
            if cursor:
                cursor.close()


    #column下拉列表内容改变(展示空间数据wkt)
    def column_box_change_with_all(self):
        #重置operateBox、typeBox、limitEdit、sridEdit
        self.reset_operateBox()
        self.reset_typeBox()
        self.reset_limitEdit()
        self.reset_sridEdit()
        #添加图层按钮设置为不可点击状态
        self.addLayerButton.setEnabled(False)

        self.column_name = self.columnBox.currentText()
        self.column_name = self.column_name.upper()
        self.schema_name = self.schema_name.upper()
        self.table_name = self.table_name.upper()
        cursor = self.conn.cursor()
        try:
            # 构建查询SQL
            # 查询当前列下所有空间数据的wkt格式
            sql = "select dmgeo2.st_astext(?) from  ?.?;" # nosec B608
            
            # 执行查询
            cursor.execute(sql, (self.column_name), (self.schema_name), (self.table_name))

            # 获取所有数据（提取查询结果的第一列）
            datas = [row[0] for row in cursor.fetchall()]
            if datas:
                self.operateBox.setCurrentIndex(-1)
                self.operateBox.setEnabled(True)
        except Exception as e:
        # 捕获其他未知错误
            iface.messageBar().pushMessage(
                "Change ColumnBox Error:", 
                sql, 
                level=Qgis.Critical)
        finally:
            if cursor:
                cursor.close()


    #column下拉列表内容改变
    def column_box_change(self):
        #重置operateBox、typeBox、limitEdit、sridEdit
        self.reset_operateBox()
        self.reset_typeBox()
        self.reset_limitEdit()
        self.reset_sridEdit()
        self.addLayerButton.setEnabled(False)

        self.column_name = self.columnBox.currentText()

        self.operateBox.setEnabled(True)
        self.typeBox.setEnabled(True)
        self.sridEdit.setEnabled(True)


    #column下拉列表内容改变
    def operate_box_change(self):
        self.operator = self.operateBox.currentText()
        #根据operator，决定limitEdit状态
        if self.operateBox.currentText() == 'ALL':
            self.reset_limitEdit()
        elif self.operateBox.currentText() == '>=v1 and <=v2':
            self.reset_limitEdit()
            self.limitEdit.hide()
            self.limitMinEdit.setEnabled(True)
            self.limitMinEdit.show()
            self.limitMaxEdit.setEnabled(True)
            self.limitMaxEdit.show()
        else:
            self.reset_limitEdit()
            self.limitEdit.setEnabled(True)


    #type下拉列表内容改变,添加图层按钮设置为可点击状态
    def type_box_change(self):
        self.type_name = self.typeBox.currentText()
        self.addLayerButton.setEnabled(True)


    #点击添加图层按钮
    def add_layer_button_clicked(self):
        self.type_name = self.typeBox.currentText()
        # operator 默认为 ALL
        self.operator = self.operateBox.currentText()
        if not self.operator:
            self.operator = 'ALL'
        # srid 默认为 4326
        self.srid = self.sridEdit.text()
        if not self.srid:
            self.srid = 4326
        # limit 默认为 1000
        self.limit = self.limitEdit.text()
        if not self.limit:
            self.limit = 1000
        # limit_min 默认为 1000
        self.limit_min = self.limitMinEdit.text()
        if not self.limit_min:
            self.limit_min = 1000
        # limit_max 默认为 1000
        self.limit_max = self.limitMaxEdit.text()
        if not self.limit_max:
            self.limit_max = 1000
        # layer_name 默认为 表名+'_'+随机四个数字或字母
        self.layer_name = self.layernameEdit.text()
        if not self.layer_name:
            self.layer_name = self.table_name + '-' + str(uuid.uuid4())[0:4]

        # 禁用按钮，防止重复点击
        self.addLayerButton.setEnabled(False)
        # 加载进度条
        self.show_progreass_bar()

        # 创建后台线程
        self.worker_thread = ImportWorker(self, self.layer_name)
        self.worker_thread.progress_updated.connect(self.update_progress)
        self.worker_thread.finished.connect(self.on_import_finished)
        self.worker_thread.error_occurred.connect(self.on_import_error)
        self.worker_thread.start()

        #layer = self.create_dynamic_layer(self.layer_name)
        # 添加到工程
        #QgsProject.instance().addMapLayer(layer, False)
        #QgsProject.instance().layerTreeRoot().insertLayer(0, layer)


    def cancel_import(self):
        """用于取消导入按钮点击后"""
        if hasattr(self, 'worker_thread') and self.worker_thread:
            # 断开导入操作按钮连接
            self.worker_thread.progress_updated.disconnect(self.update_progress)
            self.worker_thread.finished.disconnect(self.on_import_finished)
            self.worker_thread.error_occurred.disconnect(self.on_import_error)
            
            # 请求线程中断并停止
            self.worker_thread.requestInterruption()
            self.worker_thread.quit()
            self.worker_thread.wait()
            self.worker_thread = None
        
        # 销毁组件，并清空进度条和容器引用
        if hasattr(self, 'container'):
            iface.messageBar().clearWidgets()
            self.container.deleteLater()
            self.container = None
        self.progress_bar = None

        # 恢复导入按钮
        self.addLayerButton.setEnabled(True)
        
        iface.messageBar().pushMessage(
            "import operation has been interrupted",
            level = Qgis.Warning, 
            duration = 3
        )


    def on_container_destroyed(self):
        """用于监听进度条右侧X按键，默认用于销毁组件"""
        if hasattr(self, 'worker_thread') and self.worker_thread:
            # 断开导入操作按钮连接
            self.worker_thread.progress_updated.disconnect(self.update_progress)
            self.worker_thread.finished.disconnect(self.on_import_finished)
            self.worker_thread.error_occurred.disconnect(self.on_import_error)
            
            # 请求线程中断并停止
            self.worker_thread.requestInterruption()
            self.worker_thread.quit()
            self.worker_thread.wait()
            self.worker_thread = None

        # 组件销毁，清空进度条和容器引用
        self.progress_bar = None
        self.container = None
        
        # 恢复导入按钮
        self.addLayerButton.setEnabled(True)


    def cleanup_import(self):
        """通用清理函数,导入完成/导入过程报错时调用，用于清理线程与组件"""
        # 清理线程
        if hasattr(self, 'worker_thread') and self.worker_thread:
            self.worker_thread.requestInterruption()
            self.worker_thread.quit()
            self.worker_thread.wait()
            self.worker_thread = None
        
        # 清理组件
        if hasattr(self, 'container') and self.container:
            iface.messageBar().clearWidgets()
            self.container.deleteLater()
            self.container = None
        self.progress_bar = None

        # 恢复导入按钮
        self.addLayerButton.setEnabled(True)


    def show_progreass_bar(self):
        """在QGIS中显示导入进度条"""
        # 清除现有消息
        iface.messageBar().clearWidgets()
        # 创建进度条、标签
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        cancel_btn = QPushButton("cancel")
        cancel_btn.clicked.connect(self.cancel_import)
        label = QLabel("正在导入数据...")
        # 创建容器
        self.container = QWidget()
        layout = QVBoxLayout(self.container)
        layout.addWidget(label)
        layout.addWidget(self.progress_bar)
        layout.addWidget(cancel_btn)

        # 监听容器的销毁事件
        self.container.destroyed.connect(self.on_container_destroyed)

        # 添加到消息栏(持续显示， 不自动关闭)
        iface.messageBar().pushWidget(
            self.container,
            level=Qgis.Info,
            duration=0
        )
        
    
    @pyqtSlot(int)
    def update_progress(self, value):
        """更新进度条"""
        if self.progress_bar is not None:
            self.progress_bar.setValue(value)


    @pyqtSlot(object)
    def on_import_finished(self, layer):
        """导入完成后恢复状态"""
        self.cleanup_import()

        if layer:
            # 成功，添加图层到项目
            QgsProject.instance().addMapLayer(layer, False)
            QgsProject.instance().layerTreeRoot().insertLayer(0, layer)
            # 显示成功信息
            iface.messageBar().pushSuccess(
                "Success",
                f"import {layer.featureCount()} features"
            )
        else:
            # 显示失败信息
            iface.messageBar().pushCritical(
                "Critical",
                f"import features failed!"
            )


    @pyqtSlot(str)
    def on_import_error(self, error_msg):
        """线程出错时处理"""
        self.cleanup_import()

        # 显示报错信息
        iface.messageBar().pushCritical(
            "Critical",
            f"import fail: {error_msg}"
        )


    #将typeBox的类型(Point,LineString..)映射为DM的空间类型(ST_Point,ST_LineString..)
    def typebox_type_to_dm(self, box_type):
        if box_type == 'Point':
            return 'ST_Point'
        elif box_type == 'LineString':
            return 'ST_LineString'
        elif box_type == 'Polygon':
            return 'ST_Polygon'
        elif box_type == 'MultiPoint':
            return 'ST_MultiPoint'
        elif box_type == 'MultiLineString':
            return 'ST_MultiLineString'
        elif box_type == 'MultiPolygon':
            return 'ST_MultiPolygon'
        else:
            iface.messageBar().pushMessage(
                self.tr("typeBox has Error"),
                level = Qgis.Critical)
            return ''


    #将达梦数据类型映射为QGIS的QVariant类型
    def dm_type_to_qgis(self, dm_type):
        dm_type = dm_type.upper()
        if "INT" in dm_type or "NUMBER" in dm_type and "DECIMAL" not in dm_type:
            return QVariant.Int
        elif "FLOAT" in dm_type or "DOUBLE" in dm_type or "DECIMAL" in dm_type:
            return QVariant.Double
        elif "TIME" in dm_type and "DATETIME" not in dm_type and "TIMESTAMP" not in dm_type:
            return QVariant.Time
        elif "DATE" in dm_type and "TIME" not in dm_type:
            return QVariant.Date
        elif "DATETIME" in dm_type or "TIMESTAMP" in dm_type:
            return QVariant.DateTime
        else:  # 字符串、字符型等默认用String
            return QVariant.String


    def get_table_fields(self):
        #动态获取表的非空间字段元数据（字段名、数据类型）
        cursor = self.conn.cursor()
        try:
            # 查询表的所有字段（排除空间列）
            sql = """
                SELECT COLUMN_NAME, DATA_TYPE 
                FROM ALL_TAB_COLUMNS 
                WHERE OWNER = ? 
                  AND TABLE_NAME = ?
                  AND COLUMN_NAME != ?
                ORDER BY COLUMN_ID
            """# nosec B608
            cursor.execute(sql, (self.schema_name), (self.table_name), (self.column_name))
            fields = cursor.fetchall()  # 格式：[(字段名1, 类型1), (字段名2, 类型2), ...]
            return fields
        except dmPython.DatabaseError as e:
            iface.messageBar().pushCritical(self.tr("Could not find data"), f"{e.message}")
            return []
        finally:
            if cursor:
                cursor.close()


    #导入memory图层
    def import_memory_layer(self, wkt, layer_name="memory layer", crs="EPSG:4326"):
        # 判断几何类型，创建对应内存图层
        if wkt.startswith("POINT"):
            layer_type = "Point"
        elif wkt.startswith("LINESTRING"):
            layer_type = "LineString"
        elif wkt.startswith("POLYGON"):
            layer_type = "Polygon"
        else:
            raise ValueError(self.tr("Unsupported type"))

        uri = f"{layer_type}?crs={crs}"
        layer = QgsVectorLayer(uri, layer_name, "memory")
        if not layer.isValid():
            raise RuntimeError(self.tr("Failed to add leyer "))

        # 添加属性字段（示例：id 整数）
        fields = QgsFields()
        fields.append(QgsField("id", 2))  # 2 表示整数类型
        layer.dataProvider().addAttributes(fields)
        layer.updateFields()

        # 从WKT创建几何并添加要素
        geom = QgsGeometry.fromWkt(wkt)
        feat = QgsFeature()
        feat.setGeometry(geom)
        feat.setAttributes([1])
        layer.dataProvider().addFeatures([feat])
        layer.updateExtents()

        # 添加到工程 外部进行
        return layer
    

    def get_limit_data(self, fields):
        """查询所有属性字段和空间列WKT"""
        try:
            #cursor = self.conn.cursor()

            escaped_attr_fields = []
            # 1.验证并转义所有属性字段名
            for f in fields:
                field_name = f[0]
                escaped_attr_fields.append(self.escape_identifier(field_name))
            
            # 拼接所有属性字段名（用于SQL查询）
            attr_fields = ", ".join(escaped_attr_fields)  # 字段名
            int64_max = np.iinfo(np.int64).max
            escaped_schema_name = self.escape_identifier(self.schema_name)
            escaped_table_name = self.escape_identifier(self.table_name)
            escaped_column_name = self.escape_identifier(self.column_name)
            if self.operator == 'ALL':
                # 构建查询SQL
                sql = f"""
                    SELECT {attr_fields}, dmgeo2.st_astext({escaped_column_name}) FROM {escaped_schema_name}.{escaped_table_name}
                    WHERE dmgeo2.st_srid({escaped_column_name}) = ? and dmgeo2.st_geometrytype({escaped_column_name}) = ?;
                """# nosec B608
                self.cursor.execute(sql, (self.srid), (self.typebox_type_to_dm(self.type_name)))
            elif self.operator == '>=v1 and <=v2':
                # 构建查询SQL
                sql = f"""
                    SELECT {attr_fields}, dmgeo2.st_astext({escaped_column_name}) FROM
                    (
                        SELECT rownum AS rn, {attr_fields}, {escaped_column_name}        --子查询中生成行号
                        FROM {escaped_schema_name}.{escaped_table_name}
                        WHERE rownum <= ?
                    )
                    WHERE rn >= ? and rn <= ? and dmgeo2.st_srid({escaped_column_name}) = ? and dmgeo2.st_geometrytype({escaped_column_name}) = ?;
                """# nosec B608
                self.cursor.execute(sql, (int64_max), (self.limit_min), (self.limit_max), (self.srid), (self.typebox_type_to_dm(self.type_name)))
            elif self.operator == '>=':
                # 构建查询SQL
                sql = f"""
                    SELECT {attr_fields}, dmgeo2.st_astext({escaped_column_name}) FROM
                    (
                        SELECT rownum AS rn, {attr_fields}, {escaped_column_name}        --子查询中生成行号
                        FROM {escaped_schema_name}.{escaped_table_name}
                        WHERE rownum <= ?
                    )
                    WHERE rn >= ? and dmgeo2.st_srid({escaped_column_name}) = ? and dmgeo2.st_geometrytype({escaped_column_name}) = ?;
                """# nosec B608
                self.cursor.execute(sql, (int64_max), (self.limit), (self.srid), (self.typebox_type_to_dm(self.type_name)))
            elif self.operator == '>':
                # 构建查询SQL
                sql = f"""
                    SELECT {attr_fields}, dmgeo2.st_astext({escaped_column_name}) FROM
                    (
                        SELECT rownum AS rn, {attr_fields}, {escaped_column_name}       --子查询中生成行号
                        FROM {escaped_schema_name}.{escaped_table_name}
                        WHERE rownum <= ?
                    )
                    WHERE rn > ? and dmgeo2.st_srid({escaped_column_name}) = ? and dmgeo2.st_geometrytype({escaped_column_name}) = ?;
                """# nosec B608
                self.cursor.execute(sql, (int64_max), (self.limit), (self.srid), (self.typebox_type_to_dm(self.type_name)))
            elif self.operator == '=':
                # 构建查询SQL
                sql = f"""
                    SELECT {attr_fields}, dmgeo2.st_astext({escaped_column_name}) FROM
                    (
                        SELECT rownum AS rn, {attr_fields}, {escaped_column_name}        --子查询中生成行号
                        FROM {escaped_schema_name}.{escaped_table_name}
                        WHERE rownum <= ?
                    )
                    WHERE rn = ? and dmgeo2.st_srid({escaped_column_name}) = ? and dmgeo2.st_geometrytype({escaped_column_name}) = ?;
                """# nosec B608
                self.cursor.execute(sql, (int64_max), (self.limit), (self.srid), (self.typebox_type_to_dm(self.type_name)))
            elif self.operator == '<=':
                # 构建查询SQL
                sql = f"""
                    SELECT {attr_fields}, dmgeo2.st_astext({escaped_column_name}) FROM
                    (
                        SELECT rownum AS rn, {attr_fields}, {escaped_column_name}       --子查询中生成行号
                        FROM {escaped_schema_name}.{escaped_table_name}
                        WHERE rownum <= ?
                    )
                    WHERE rn <= ? and dmgeo2.st_srid({escaped_column_name}) = ? and dmgeo2.st_geometrytype({escaped_column_name}) = ?;
                """# nosec B608
                self.cursor.execute(sql, (int64_max), (self.limit), (self.srid), (self.typebox_type_to_dm(self.type_name)))
            else:
                # 构建查询SQL
                sql = f"""
                    SELECT {attr_fields}, dmgeo2.st_astext({escaped_column_name}) FROM 
                    (
                        SELECT rownum AS rn, {attr_fields}, {escaped_column_name}        --子查询中生成行号
                        FROM {escaped_schema_name}.{escaped_table_name}
                        WHERE rownum <= ?
                    )
                    WHERE rn < ? and dmgeo2.st_srid({escaped_column_name}) = ? and dmgeo2.st_geometrytype({escaped_column_name}) = ?;
                """# nosec B608
                self.cursor.execute(sql, (int64_max), (self.limit), (self.srid), (self.typebox_type_to_dm(self.type_name)))
            return
        except dmPython.DatabaseError as e:
            iface.messageBar().pushMessage(
                "get_limit_data Error:", 
                sql,
                level=Qgis.Critical)
            return
        except ValueError as e:
            QMessageBox.critical(self, "Input error", str(e))
        

    def get_total_size(self):
        cursor = self.conn.cursor()
        try:
            escaped_schema_name = self.escape_identifier(self.schema_name)
            escaped_table_name = self.escape_identifier(self.table_name)
            # 查询表的所有字段（排除空间列）
            sql = f"""
                SELECT count(*)
                FROM {escaped_schema_name}.{escaped_table_name};
            """# nosec B608
            cursor.execute(sql)
            return cursor.fetchone()
        except dmPython.DatabaseError as e:
            iface.messageBar().pushCritical(self.tr("Could not get total size"), f"{e.message}")
            return []
        finally:
            if cursor:
                cursor.close()

        
    def closeEvent(self, event):
        self.plugin.quit_plugin()
        event.accept()  # 接受关闭事件